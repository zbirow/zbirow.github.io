<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Muffin P2P 1.7</title>
    <style>
        body { font-family: monospace; background: #000; color: #0f0; margin: 0; padding: 10px; padding-bottom: 50px; }
        .panel { border: 1px solid #333; padding: 10px; margin-bottom: 15px; background: #111; }
        textarea { width: 100%; height: 60px; background: #222; color: #fff; border: 1px solid #555; font-size:10px; }
        button { background: #004400; color: #fff; border: 1px solid #0f0; padding: 12px; cursor: pointer; width: 100%; margin-top: 5px; font-weight:bold;}
        #player-box { margin-top: 10px; }
        video { width: 100%; border: 1px solid #333; background: #000; max-height: 80vh; }
        .hidden { display: none; }
        #logs { color: #888; font-size: 10px; height: 100px; overflow-y: scroll; border-top: 1px dashed #333; margin-top: 20px; word-break: break-all;}
    </style>
</head>
<body>

    <h1 style="text-align:center; border-bottom:1px solid #0f0;">P2P INSTANT META</h1>

    <div id="setup" class="panel">
        <input type="password" id="secret-key" value="tajne123" placeholder="Hasło...">
        <div style="display:flex; gap:10px; margin-top:10px;">
            <button onclick="initHost()">HOST</button>
            <button onclick="initClient()">KLIENT</button>
        </div>
    </div>

    <div id="host-ui" class="panel hidden">
        <h3>HOST</h3>
        <input type="file" id="file-input">
        <button onclick="createOffer()">1. GENERUJ OFERTĘ (Z Plikiem)</button>
        <textarea id="host-offer-out" readonly onclick="this.select()"></textarea>
        <textarea id="host-answer-in" placeholder="Tu wklej odpowiedź..."></textarea>
        <button onclick="finalizeConnection()">2. POŁĄCZ</button>
    </div>

    <div id="client-ui" class="panel hidden">
        <h3>KLIENT</h3>
        <textarea id="client-offer-in" placeholder="Tu wklej ofertę..."></textarea>
        <button onclick="createAnswer()">1. GENERUJ ODPOWIEDŹ</button>
        <textarea id="client-answer-out" readonly onclick="this.select()"></textarea>
        
        <div id="player-box" class="hidden">
            <p>Status: <span id="status-text" style="color:yellow">Czekam na ofertę...</span></p>
            <video id="video-player" controls playsinline webkit-playsinline></video>
        </div>
    </div>

    <div id="logs">Logi...</div>

    <script>
        const config = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };
        const CHUNK_MTU = 16 * 1024; 

        let pc, dataChannel;
        let file = null; 
        
        // Klient
        let fileSize = 0; 
        let incomingChunks = [];
        let currentRequestId = null;

        function log(msg) { 
            console.log(msg);
            const l = document.getElementById('logs');
            l.innerHTML = `> ${msg}<br>` + l.innerHTML; 
        }

        function initHost() {
            document.getElementById('setup').classList.add('hidden');
            document.getElementById('host-ui').classList.remove('hidden');
            setupPeer('host');
            document.getElementById('file-input').addEventListener('change', e => {
                file = e.target.files[0];
                log(`Wybrano: ${file.name} (${file.size} B)`);
            });
        }

        async function initClient() {
            document.getElementById('setup').classList.add('hidden');
            document.getElementById('client-ui').classList.remove('hidden');
            setupPeer('client');
            
            try {
                // Rejestracja SW
                const reg = await navigator.serviceWorker.register('sw.js', { scope: './' });
                await reg.update();
                await navigator.serviceWorker.ready;
                navigator.serviceWorker.addEventListener('message', event => handleSwMessage(event.data));
                log("Service Worker OK");
            } catch (err) { alert("SW Error: " + err); }
        }

        function setupPeer(role) {
            pc = new RTCPeerConnection(config);
            pc.oniceconnectionstatechange = () => {
                if(pc.iceConnectionState === 'connected') {
                    if (role === 'client') {
                        document.getElementById('status-text').innerText = "Połączono P2P.";
                        startVideoPlayback(); // Startujemy odtwarzacz, bo rozmiar już mamy!
                    }
                }
            };

            if (role === 'host') {
                dataChannel = pc.createDataChannel("p2p-stream", { ordered: true });
                dataChannel.onmessage = handleHostData;
            } else {
                pc.ondatachannel = e => {
                    dataChannel = e.channel;
                    dataChannel.onmessage = handleClientData;
                    dataChannel.onopen = () => log("Kanał P2P gotowy.");
                };
            }
        }

        // --- HOST ---
        function handleHostData(event) {
            const msg = JSON.parse(event.data);
            
            // UWAGA: Nie musimy już obsługiwać META_REQ, bo klient zna rozmiar z oferty!
            // Ale zostawiamy dla wstecznej kompatybilności w razie czego
            if (msg.type === 'META_REQ') {
                if(file) dataChannel.send(JSON.stringify({ type: 'META_RES', size: file.size }));
            }
            else if (msg.type === 'READ_REQ') {
                const reader = new FileReader();
                reader.onload = e => {
                    const fullBuffer = e.target.result;
                    dataChannel.send(JSON.stringify({ type: 'BATCH_START', id: msg.id }));
                    
                    let offset = 0;
                    while(offset < fullBuffer.byteLength) {
                        dataChannel.send(fullBuffer.slice(offset, offset + CHUNK_MTU));
                        offset += CHUNK_MTU;
                    }

                    dataChannel.send(JSON.stringify({ type: 'BATCH_DONE', id: msg.id }));
                };
                reader.readAsArrayBuffer(file.slice(msg.start, msg.end + 1));
            }
        }

        // --- CLIENT ---
        function handleClientData(event) {
            const data = event.data;

            if (typeof data === 'string') {
                const msg = JSON.parse(data);
                if (msg.type === 'BATCH_START') {
                    currentRequestId = msg.id;
                    incomingChunks = [];
                }
                else if (msg.type === 'BATCH_DONE') {
                    if (currentRequestId === msg.id && incomingChunks.length > 0) {
                        const finalBlob = new Blob(incomingChunks);
                        finalBlob.arrayBuffer().then(buffer => {
                            if (navigator.serviceWorker.controller) {
                                navigator.serviceWorker.controller.postMessage({
                                    type: 'DATA_CHUNK', id: currentRequestId, buffer: buffer
                                }, [buffer]);
                            }
                        });
                        currentRequestId = null;
                        incomingChunks = [];
                    }
                }
                return;
            }

            if (currentRequestId) incomingChunks.push(data);
        }

        function handleSwMessage(msg) {
            // SW nie powinien już pytać o GET_SIZE, bo mu go daliśmy przy starcie.
            // Ale jeśli zapyta (np. po restarcie SW), to odpowiadamy.
            if (msg.type === 'GET_SIZE') {
                if(fileSize > 0 && navigator.serviceWorker.controller) {
                    navigator.serviceWorker.controller.postMessage({ 
                        type: 'SET_META', size: fileSize 
                    }); // Aktualizujemy cache SW
                }
            }
            else if (msg.type === 'GET_DATA') {
                // Jeśli kanał nie jest gotowy, ignorujemy lub logujemy błąd
                if (dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify({
                        type: 'READ_REQ', start: msg.start, end: msg.end, id: msg.id
                    }));
                } else {
                    log("Czekaj! P2P jeszcze nie połączone.");
                }
            }
        }

        function startVideoPlayback() {
            document.getElementById('player-box').classList.remove('hidden');
            const video = document.getElementById('video-player');
            // Unikamy cache'owania przeglądarki
            if (!video.src.includes('virtual-video')) {
                video.src = 'virtual-video.mp4?t=' + Date.now(); 
                video.load();
            }
        }

        // --- KRYPTO & LOGIKA PAKOWANIA METADANYCH W HANDSHAKE ---
        
        async function getKeys() {
            const pass = document.getElementById('secret-key').value;
            const enc = new TextEncoder();
            const keyMat = await crypto.subtle.importKey("raw", enc.encode(pass), {name:"PBKDF2"}, false, ["deriveKey"]);
            return window.crypto.subtle.deriveKey({name: "PBKDF2", salt: new Uint8Array(16), iterations: 1000, hash: "SHA-256"}, keyMat, {name: "AES-GCM", length: 256}, false, ["encrypt", "decrypt"]);
        }
        async function encrypt(text) {
            const key = await getKeys();
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const enc = new TextEncoder();
            const data = await window.crypto.subtle.encrypt({name:"AES-GCM", iv:iv}, key, enc.encode(text));
            const buff = new Uint8Array(iv.byteLength + data.byteLength);
            buff.set(iv,0); buff.set(new Uint8Array(data),12);
            return btoa(String.fromCharCode(...buff));
        }
        async function decrypt(b64) {
            try {
                const bin = atob(b64);
                const bytes = new Uint8Array(bin.length);
                for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i);
                const iv = bytes.slice(0,12);
                const data = bytes.slice(12);
                const key = await getKeys();
                const dec = await window.crypto.subtle.decrypt({name:"AES-GCM", iv:iv}, key, data);
                return new TextDecoder().decode(dec);
            } catch(e) { alert("Złe hasło!"); return ""; }
        }

        // --- NOWY HANDSHAKE Z METADANYMI ---

        async function createOffer() {
            if (!file) return alert("Najpierw wybierz plik!");

            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            
            pc.onicecandidate = async e => {
                if(!e.candidate) {
                    // TWORZYMY SUPER-PAKIET: SDP + Rozmiar pliku
                    const payload = {
                        sdp: pc.localDescription,
                        meta: { size: file.size, name: file.name }
                    };
                    
                    const encrypted = await encrypt(JSON.stringify(payload));
                    document.getElementById('host-offer-out').value = encrypted;
                    log("Oferta wygenerowana (zawiera metadane pliku).");
                }
            }
        }

        async function createAnswer() {
            const txt = document.getElementById('client-offer-in').value;
            if(!txt) return;

            // 1. Odszyfrujemy Super-Pakiet
            const decryptedJson = await decrypt(txt);
            if (!decryptedJson) return;
            
            const payload = JSON.parse(decryptedJson);
            
            // 2. Wyciągamy metadane i ZAPISUJEMY JE OD RAZU
            fileSize = payload.meta.size;
            log(`Odebrano ofertę. Plik: ${payload.meta.name}, Rozmiar: ${fileSize}`);
            
            // 3. Wysyłamy rozmiar do Service Workera NATYCHMIAST
            if (navigator.serviceWorker.controller) {
                navigator.serviceWorker.controller.postMessage({
                    type: 'SET_META',
                    size: fileSize
                });
                log("Metadane wysłane do SW (Cache).");
            } else {
                log("Ostrzeżenie: SW nieaktywny?");
            }

            // 4. Kontynuujemy WebRTC
            await pc.setRemoteDescription(new RTCSessionDescription(payload.sdp));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            
            pc.onicecandidate = async e => {
                if(!e.candidate) document.getElementById('client-answer-out').value = await encrypt(JSON.stringify(pc.localDescription));
            }
        }

        async function finalizeConnection() {
            const txt = document.getElementById('host-answer-in').value;
            if(!txt) return;
            // Odpowiedź zawiera tylko SDP (bez meta, bo Host już zna plik)
            const desc = JSON.parse(await decrypt(txt));
            await pc.setRemoteDescription(new RTCSessionDescription(desc));
        }
    </script>
</body>
</html>
